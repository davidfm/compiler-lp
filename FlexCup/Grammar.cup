/**
    Copyright (C) 2012 David Fernández

LICENSE:

    This file is part of CalculatorCompiler.

    CalculatorCompiler is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    CalculatorCompiler is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with CalculatorCompiler. If not, see <http://www.gnu.org/licenses/>.

@author David Fernández <davidfm[at]linux[dot]com>
@license http://www.gnu.org/licenses
@copyright 2012 David Fernández

*/

package es.davidfm.compiler.analysis;

import java_cup.runtime.*;
import java.io.*;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Iterator;

import es.davidfm.compiler.ast.structure.*;
import es.davidfm.compiler.ast.expression.*;
import es.davidfm.compiler.ast.statement.*;
import es.davidfm.compiler.generator.*;



parser code{:

	public static void main (String [] args) throws Exception{

		if (args.length!=1)
			System.out.println("Error. No file to process");
		else{
			try{
				
				Lexer lexer = new Lexer(new FileReader(args[0]));	
				new parser(lexer).parse();

			}catch(Exception e){
				
				System.out.println("Error");


			}			
	
	}
}	


:}





action code {:

	Program program;
	int memory = 0;
	int whileCounter = 0;

	ArrayList<Statement> auxBody = new ArrayList<Statement>();
	ArrayList<Variable> auxVariables = new ArrayList<Variable>();

	Stack<ArrayList<Statement>> auxStack = new Stack<ArrayList<Statement>>();
	Stack<Integer> auxMemoryStack = new Stack<Integer>();
	Stack<ArrayList<Variable>> auxVariablesStack = new Stack<ArrayList<Variable>>();
	
	private void init(){
	
		program = new Program();
	
	}
	
	
	private void end() throws IOException{
		
		
		CodeGenerator cg = new CodeGenerator(program);
		cg.generateAsm();
		
	
	}



	private Variable getVariable(String id){
		
		boolean found = false;
		Variable v = null;		
	
		Iterator it = auxVariables.iterator();
		
		while (it.hasNext() && !found){

			Variable aux = (Variable) it.next();
			
			if (aux.equals(id)){

				found = true;
				v = aux;
			}
		}

		if (found){
			return v;

		} else {

		it = auxVariablesStack.iterator();

		while (it.hasNext() && !found){

			ArrayList<Variable> aux = (ArrayList<Variable>) it.next();
			
			Iterator<Variable> it2 = aux.iterator();

			while (it2.hasNext() && !found){

				Variable vaux = it2.next();

				if (vaux.equals(id)){

					found = true;
					v = vaux;
				}
			

			
	}
		

	}

	return v;

}

}
	
:}


terminal String PLUS;
terminal String MINUS;
terminal String TIMES;
terminal String DIV;
terminal String LPAREN;
terminal String RPAREN;
terminal String LBRACE;
terminal String RBRACE;
terminal String LBRACKET;
terminal String RBRACKET;
terminal String INTEGER;
terminal String FLOAT;
terminal String BOOLEAN;
terminal String STRING;
terminal String SEMI;
terminal String COMMA;
terminal String ASSIGN;
terminal String MAIN;
terminal String PRINT;
terminal String PRINTLN;
terminal String NUM_INTEGER;
terminal String NUM_FLOAT;
terminal String BOOL;
terminal String ID;
terminal String STRG;
terminal String WHILE;
terminal String EQUALS;
terminal String DIFFERENT;
terminal String GREATER;
terminal String LESS;
terminal String LESSEQUAL;
terminal String GREATEREQUAL;



non terminal Program Program;
non terminal BlockStatement Body;
non terminal Statement Statement;
non terminal Declaration;
non terminal AssignStatement Assign;
non terminal String Type;
non terminal Expression Expression;
non terminal PrintStatement Print;
non terminal PrintLineStatement Println;
non terminal WhileStatement While;
non terminal ArrayList<Statement> Statements;



precedence left BOOL;
precedence left STRG;
precedence left NUM_INTEGER;
precedence left NUM_FLOAT;
precedence right ID;


precedence left LESS, GREATER, DIFFERENT, EQUALS, GREATEREQUAL, LESSEQUAL;

precedence left ASSIGN;
precedence left PLUS;
precedence left MINUS;
precedence left TIMES;
precedence left DIV;
precedence left LPAREN, RPAREN;

start with Program;

Program ::= {: System.out.println("Beginning the analysis");
			init();
			 :}		
 			MAIN LPAREN RPAREN LBRACE Body:b RBRACE
			{:	
				program.setBody(b);
				System.out.println("Analysis finished succesfully");
				end();
				System.out.println("Code generated succesfully");				
  			:};


Body ::= Statements {: RESULT = new BlockStatement(auxVariables, auxBody); :};
		
Statements ::= Statement Statements  | Statement {: RESULT = auxBody; :};
			
Statement ::= Declaration 
			| Assign:a {: auxBody.add(a); :}
			| Print:p {: auxBody.add(p); :}
			| Println:pl {: auxBody.add(pl); :}
			| While:w {: auxBody.add(w); :};
	
Declaration ::= Type:t ID:id SEMI
				{: if (program.containsVariable(id)){
					System.out.println("Variable " + id + " is already declared");
					} else {

						if (!t.equals("String")){
						Variable v = new Variable(t,id, memory);
						memory+=4;
						program.addVariable(v);
						auxVariables.add(v);

						} else {
							Variable v = new Variable(t,id, -1);
							program.addVariable(v);
							auxVariables.add(v);
						}
							
					}

				:};
					
				
Assign ::= ID:id2 ASSIGN Expression:e SEMI
			{: if (program.containsVariable(id2)){
				Variable v = getVariable(id2);
				RESULT = new AssignStatement(v,e);
			} else {
				System.out.println("Error. Variable not declared.");
			}

			:};

 		
Type ::= INTEGER {: RESULT = new String("int"); :}
		|FLOAT {: RESULT = new String("float"); :} 
		|STRING {: RESULT = new String("String"); :};

Expression ::= Expression:e1 PLUS Expression:e2 {: RESULT = new BinaryExpression("+",e1,e2,memory); memory+=4; :}
|Expression:e1 MINUS Expression:e2 {: RESULT = new BinaryExpression("-",e1,e2,memory); memory+=4; :}
|Expression:e1 TIMES Expression:e2 {: RESULT = new BinaryExpression("*",e1,e2,memory); memory+=4; :}
|Expression:e1 DIV Expression:e2 {: RESULT = new BinaryExpression("/",e1,e2,memory); memory+=4; :}
|Expression:e1 EQUALS Expression:e2 {: RESULT = new BinaryExpression("==",e1,e2,memory); memory+=4; :}
|Expression:e1 DIFFERENT Expression:e2 {: RESULT = new BinaryExpression("!=",e1,e2,memory); memory+=4; :}
|Expression:e1 GREATER Expression:e2 {: RESULT = new BinaryExpression(">",e1,e2,memory); memory+=4;  :}
|Expression:e1 LESS Expression:e2 {: RESULT = new BinaryExpression("<",e1,e2,memory); memory+=4;:}
|Expression:e1 LESSEQUAL Expression:e2 {: RESULT = new BinaryExpression("<",e1,e2,memory); memory+=4; :}
|Expression:e1 GREATEREQUAL Expression:e2 {: RESULT = new BinaryExpression("<",e1,e2,memory); memory+=4; :}
|NUM_INTEGER:i {: RESULT = new IntegerLiteralExpression(i, memory); memory+=4; :}
|NUM_FLOAT:f {: RESULT = new FloatLiteralExpression(f, memory); memory+=4; :}
|STRG:s {: RESULT = new StringLiteralExpression(s); :}
|ID:id {: 	Variable v = getVariable(id);
			RESULT = new VariableExpression(v);
		:}
|LPAREN Expression:e RPAREN {: RESULT = e; :}  ;
Print ::= PRINT LPAREN ID:id RPAREN SEMI {:
	if (program.containsVariable(id)){
 		RESULT = new PrintStatement(getVariable(id));
	} else {

		System.out.println("Error. Variable not declared.");

	 }
:};

Println ::= PRINTLN LPAREN ID:id RPAREN SEMI {:
	if (program.containsVariable(id)){
 		RESULT = new PrintLineStatement(getVariable(id));
	} else {

		System.out.println("Error. Variable not declared.");

	 }
:};

While ::={: 	auxStack.push(auxBody);
		auxMemoryStack.push(memory);
		auxBody = new ArrayList<Statement>();
		program.newScope();
		auxVariablesStack.push(auxVariables);
		auxVariables = new ArrayList<Variable>();
	:}
WHILE LPAREN Expression:e RPAREN LBRACE Body:b RBRACE

{:	RESULT = new WhileStatement(whileCounter,e,b);
	whileCounter++;
	program.deleteScope();
	auxBody = auxStack.pop();
	memory = auxMemoryStack.pop();
	auxVariables = auxVariablesStack.pop();	
:};





 
